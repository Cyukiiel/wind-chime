
<!doctype html>
<html lang="zh-CN"><head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>風鈴 · DebugMini v18 (Damped Physics)</title>
<style>
  html,body{height:100%;margin:0;background:#061227;color:#e6eefc;font-family:-apple-system,system-ui,Segoe UI,Roboto,PingFang SC,Hiragino Sans;}
  #fw{position:fixed;inset:0;z-index:0;pointer-events:none}
  .app{position:relative;z-index:1;height:100vh;max-width:520px;margin:0 auto;background:rgba(5,10,20,.55);backdrop-filter:blur(3px);display:flex;flex-direction:column;align-items:center;padding:12px 16px}
  .canvas{flex:1;display:flex;align-items:center;justify-content:center;width:100%}
  .controls{display:flex;gap:8px;flex-wrap:wrap;width:100%}
  button{flex:1;padding:10px 12px;border-radius:12px;border:2px solid #60a5ff;background:rgba(255,255,255,.06);color:#e6eefc;font-weight:600}
  button.on{background:#60a5ff;color:#03203c}
  .row{display:flex;gap:8px;width:100%;align-items:center}
  #err{position:fixed;left:8px;right:8px;top:8px;background:#ff3b30;color:#fff;padding:8px 10px;border-radius:10px;display:none;z-index:9;white-space:pre-wrap}
</style></head>
<body>
<div id="err"></div>
<canvas id="fw"></canvas>
<div class="app">
  <div class="canvas">
    <svg id="svg" viewBox="0 0 360 520" style="width:360px;height:520px">
      <g transform="translate(180,120) rotate(45) translate(-85,-85)"><rect x="0" y="0" width="170" height="170" rx="22" fill="#0b1a33" stroke="#60a5ff" stroke-width="6"/></g>
      <text x="180" y="120" text-anchor="middle" fill="#d7e2ff" font-size="20" font-weight="700">風有在吹嗎？</text>
      <g id="asm" transform="rotate(0 180 220)">
        <text x="205" y="220" fill="#a7b4d9" font-size="16">yes</text>
        <line x1="180" y1="200" x2="180" y2="240" stroke="#9fb7ff" stroke-width="3"/>
        <g id="bell">
          <path d="M130,300 Q180,230 230,300 L230,330 Q180,350 130,330 Z" fill="#9ec9ff33" stroke="#8db2ff" stroke-width="2"/>
          <ellipse cx="180" cy="300" rx="50" ry="10" fill="#8fb9ff" opacity="0.9"/>
          <line id="clapperLine" x1="180" y1="300" x2="180" y2="364" stroke="#aecdff" stroke-width="2"/>
          <circle id="clapper" cx="180" cy="372" r="10" fill="#c2d2ff"/>
        </g>
        <g id="tz">
          <line x1="180" y1="382" x2="180" y2="392" stroke="#9fb7ff" stroke-width="2"/>
          <rect x="165" y="392" width="30" height="70" rx="4" fill="#0f1c33" stroke="#324b7a"/>
          <text x="180" y="397" text-anchor="middle" fill="#b7d0ff" font-size="14" style="writing-mode:vertical-rl">香橙布叮铃铃</text>
        </g>
      </g>
    </svg>
  </div>
  <div class="controls">
    <button id="toggle">有風（開始）</button>
    <button id="hit">只響一下</button>
    <button id="hanabi" class="on">花火大会（開）</button>
  </div>
  <div class="row"><span>風速</span><input id="rate" type="range" min="0" max="100" value="40"><span id="st">待機中</span></div>
</div>

<script>
(function(){const b=document.getElementById('err');addEventListener('error',e=>{b.style.display='block';b.textContent='[Error] '+e.message;});addEventListener('unhandledrejection',e=>{b.style.display='block';b.textContent='[Rejection] '+e.reason;});})();

document.addEventListener('DOMContentLoaded', function(){
  const $=id=>document.getElementById(id);
  const asm=$('asm'), bell=$('bell'), tz=$('tz'), clapper=$('clapper');
  const toggle=$('toggle'), hit=$('hit'), rate=$('rate'), st=$('st'), btnHanabi=$('hanabi');

  // --- Audio (minimal) ---
  const actx=new (window.AudioContext||window.webkitAudioContext)();
  function chime(){const now=actx.currentTime;
    function tone(f,t){const o=actx.createOscillator(),g=actx.createGain();o.type='sine';o.frequency.value=f;g.gain.setValueAtTime(0,now+t);g.gain.linearRampToValueAtTime(.9,now+t+.01);g.gain.exponentialRampToValueAtTime(.0001,now+t+1.3);o.connect(g).connect(actx.destination);o.start(now+t);o.stop(now+t+1.4);}
    tone(1400,0);tone(1000,.03);tone(1800,.12); addKick(80);
  }

  // --- Damped pendulum physics (eliminate jitter) ---
  let raf=null, running=false, timer=null, tempAnimating=false;
  let theta=0, omega=0, lastTS=0, phase=0; // angle(rad), angular vel, for wind drive
  function addKick(power){ omega += (power||60) * Math.PI/180; } // add to angular velocity (rad/s)

  function step(ts){
    if(!lastTS) lastTS = ts;
    const dt = Math.min(0.05, (ts - lastTS)/1000); // clamp dt <=50ms
    lastTS = ts;

    // natural frequency & damping
    const T = 2.6; // period (s) around small angle
    const wn = 2*Math.PI / T;    // rad/s
    const zeta = 0.12 + (+rate.value)/1000; // damping ratio grows slightly with wind speed

    // wind drive as torque-like term
    const r = +rate.value;
    const windFreq = 0.25 + r/400; // Hz
    phase += 2*Math.PI*windFreq*dt;
    const drive = (5 + r*0.08) * Math.PI/180 * Math.sin(phase); // radians

    // second-order system: theta'' + 2*zeta*wn*theta' + wn^2*theta = drive'' ~ k*drive
    // We treat "drive" as external acceleration on angle:
    const alpha = -2*zeta*wn*omega - wn*wn*theta + drive*wn*wn*0.6;

    omega += alpha * dt;
    // clamp omega to avoid numerical explosion at large impulses
    const wClamp = 8; if(omega > wClamp) omega = wClamp; else if(omega < -wClamp) omega = -wClamp;
    theta += omega * dt;

    // Deadband to prevent tiny forever jiggle when not running
    if(!running){
      if(Math.abs(theta) < (0.4*Math.PI/180) && Math.abs(omega) < (0.4*Math.PI/180)){
        theta = 0; omega = 0;
        if(tempAnimating){
          tempAnimating = false;
          cancelAnimationFrame(raf); raf=null;
          // reset transforms
          asm.setAttribute('transform','rotate(0 180 220)');
          bell.removeAttribute('transform'); tz.removeAttribute('transform'); clapper.removeAttribute('transform');
          st.textContent = '待機中';
          return;
        }
      }
    }

    // convert to degrees for SVG
    const deg = theta * 180/Math.PI;
    asm.setAttribute('transform','rotate('+deg+' 180 220)');

    // Subparts: critically-damped follow to remove twitch
    // Use simple first-order lag following main angle, no feedback overshoot
    const bellDeg = deg * 0.22;
    const tzDeg   = deg * 0.42;
    const clapDeg = deg * 0.30;

    // low-pass filter states
    if(step._bell===undefined){ step._bell=0; step._tz=0; step._clap=0; }
    const lp = (v, target, s)=> v + (target - v) * (1 - Math.exp(-s*dt));
    step._bell = lp(step._bell, bellDeg, 6.0);
    step._tz   = lp(step._tz,   tzDeg,   3.5);
    step._clap = lp(step._clap, clapDeg, 7.5);

    bell.setAttribute('transform','rotate('+step._bell+' 180 300)');
    tz.setAttribute('transform','rotate('+step._tz+' 180 392)');
    clapper.setAttribute('transform','rotate('+step._clap+' 180 300)');

    raf = requestAnimationFrame(step);
  }

  function start(){ if(running) return; running=true; toggle.classList.add('on'); toggle.textContent='停風（停止）'; st.textContent='風在吹：響鈴中…';
    if(!raf){ lastTS=0; raf=requestAnimationFrame(step); } schedule(); }
  function stop(){ running=false; toggle.classList.remove('on'); toggle.textContent='有風（開始）'; st.textContent='待機中';
    clearTimeout(timer); timer=null; // 不立即取消 RAF，让物理自然衰减；当进入 deadband 会自动停
  }
  function schedule(){ const r=+rate.value, base=2000-r*15, jitter=Math.random()*600;
    timer=setTimeout(function(){ chime(); if(running) schedule(); }, Math.max(300, base+jitter)); }

  toggle.addEventListener('click',function(){ if(actx.state==='suspended') actx.resume(); running?stop():start(); });
  hit.addEventListener('click',function(){ if(actx.state==='suspended') actx.resume(); chime();
    if(!running){ // run a temporary decay sim and auto-stop
      if(!raf){ tempAnimating=true; lastTS=0; raf=requestAnimationFrame(step); }
    }
  });

  // --- Lightweight Hanabi with restartable scheduler ---
  const cvs=$('fw'), ctx=cvs.getContext('2d',{alpha:true}); const DPR=Math.min(window.devicePixelRatio||1,1.5);
  function resize(){cvs.width=Math.floor(innerWidth*DPR);cvs.height=Math.floor(innerHeight*DPR);ctx.setTransform(DPR,0,0,DPR,0,0);} resize(); addEventListener('resize',resize);
  let hanabiOn=true, launchTimer=null; const particles=[];
  btnHanabi.addEventListener('click',()=>{ hanabiOn=!hanabiOn; btnHanabi.classList.toggle('on',hanabiOn); btnHanabi.textContent=hanabiOn?'花火大会（開）':'花火大会（關）'; if(hanabiOn){ scheduleLaunch(); } else { if(launchTimer){ clearTimeout(launchTimer); launchTimer=null; } } });
  function spawnRocket(){ const x=Math.random()*innerWidth*.7+innerWidth*.15; const targetY=Math.random()*innerHeight*.4+60; particles.push({x:x,y:innerHeight+10,vy:-7-Math.random()*3,stage:0,targetY,color:'#ffd166'}); }
  function scheduleLaunch(){ if(!hanabiOn) return; spawnRocket(); launchTimer=setTimeout(scheduleLaunch, 900+Math.random()*900); }
  scheduleLaunch();
  function explode(x,y){ for(let i=0;i<80;i++){ const a=Math.random()*Math.PI*2,s=Math.random()*4+1; particles.push({x:x,y:y,vx:Math.cos(a)*s,vy:Math.sin(a)*s,life:60+Math.random()*30,stage:1,color:i%3? '#ffd166':'#ff6a6a'});} }
  function stepFW(){ ctx.clearRect(0,0,cvs.width/DPR,cvs.height/DPR); for(let i=particles.length-1;i>=0;i--){ const p=particles[i];
      if(p.stage===0){ p.y+=p.vy; ctx.fillStyle=p.color; ctx.fillRect(p.x-1,p.y-6,2,12); if(p.y<=p.targetY){ explode(p.x,p.y); particles.splice(i,1);} }
      else{ p.x+=p.vx; p.y+=p.vy; p.vy+=.02; p.life--; ctx.globalAlpha=Math.max(p.life/80,0); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x,p.y,2,0,7); ctx.fill(); ctx.globalAlpha=1; if(p.life<=0) particles.splice(i,1); }
    } requestAnimationFrame(stepFW); }
  stepFW();
});
</script>
</body></html>
